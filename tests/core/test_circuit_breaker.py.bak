"""
Comprehensive tests for circuit breaker implementation.

This test suite validates the circuit breaker pattern implementation for Redis,
TWS, and LLM dependencies with proper configuration, state transitions,
and integration with logging and metrics.
"""

import asyncio
import pytest
from datetime import timedelta
from unittest.mock import Mock, patch
from typing import Any, Dict

from resync.core.circuit_breakers import redis_breaker, tws_breaker, llm_breaker
from resync.core.structured_logger import get_logger
from resync.core.metrics import runtime_metrics
from resync.core.exceptions import AuthenticationError, LLMError, RedisConnectionError

# Configure logger for testing
logger = get_logger(__name__)


class TestCircuitBreakerConfiguration:
    """Test circuit breaker configuration parameters."""
    
    def test_redis_breaker_configuration(self):
        """Test Redis circuit breaker configuration."""
        assert redis_breaker.fail_max == 3
        assert redis_breaker.timeout_duration == timedelta(seconds=30)
        assert redis_breaker.exclude == [ValueError, TypeError]
        assert redis_breaker.name == "redis_operations"
        
    def test_tws_breaker_configuration(self):
        """Test TWS circuit breaker configuration."""
        assert tws_breaker.fail_max == 5
        assert tws_breaker.timeout_duration == timedelta(seconds=60)
        assert tws_breaker.exclude == [AuthenticationError]
        assert tws_breaker.name == "tws_operations"
        
    def test_llm_breaker_configuration(self):
        """Test LLM circuit breaker configuration."""
        assert llm_breaker.fail_max == 2
        assert llm_breaker.timeout_duration == timedelta(seconds=45)
        assert llm_breaker.exclude == [LLMError]
        assert llm_breaker.name == "llm_operations"
        

class TestCircuitBreakerStateTransitions:
    """Test circuit breaker state transitions with proper exception handling."""
    
    @pytest.mark.asyncio
    async def test_redis_circuit_breaker_opening(self):
        """Test that Redis circuit breaker opens after 3 failures."""
        # Create a mock function that raises ConnectionError
        async def failing_redis_operation():
            raise RedisConnectionError("Simulated Redis connection error")
        
        # Test that the circuit breaker opens after 3 failures
        for i in range(3):
            try:
                await redis_breaker.call_async(failing_redis_operation)
                assert False, "Expected ConnectionError to be raised"
            except RedisConnectionError:
                # Expected behavior - failure should be counted
                pass
        
        # Fourth call should fail-fast with CircuitBreakerError
        try:
            await redis_breaker.call_async(failing_redis_operation)
            assert False, "Expected CircuitBreakerError to be raised"
        except Exception as e:
            # Verify it's a CircuitBreakerError (aiobreaker specific)
            assert "CircuitBreakerError" in str(type(e)) or "open" in str(e).lower()
            
        # Verify state is OPEN
        assert redis_breaker.current_state.__class__.__name__ == "CircuitOpenState"
        
    @pytest.mark.asyncio
    async def test_redis_circuit_breaker_half_open_recovery(self):
        """Test that Redis circuit breaker transitions to HALF-OPEN after timeout."""
        # Create a mock function that raises ConnectionError
        async def failing_redis_operation():
            raise RedisConnectionError("Simulated Redis connection error")
        
        # Create a mock function that succeeds
        async def successful_redis_operation():
            return "success"
        
        # Open the circuit breaker
        for i in range(3):
            try:
                await redis_breaker.call_async(failing_redis_operation)
            except RedisConnectionError:
                pass
        
        # Verify circuit is OPEN
        assert redis_breaker.current_state.__class__.__name__ == "CircuitOpenState"
        
        # Wait for timeout (30 seconds) - we'll simulate this by resetting
        # In real tests, we'd need to wait, but for unit tests we can reset
        redis_breaker.reset()
        
        # Now test that it works normally
        result = await redis_breaker.call_async(successful_redis_operation)
        assert result == "success"
        
        # Verify state is CLOSED
        assert redis_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
    @pytest.mark.asyncio
    async def test_tws_circuit_breaker_excludes_authentication_errors(self):
        """Test that TWS circuit breaker doesn't open on AuthenticationError."""
        # Create a mock function that raises AuthenticationError
        async def failing_tws_operation():
            raise AuthenticationError("Simulated TWS authentication error")
        
        # Test that AuthenticationError doesn't trigger circuit breaker
        for i in range(10):
            try:
                await tws_breaker.call_async(failing_tws_operation)
                assert False, "Expected AuthenticationError to be raised"
            except AuthenticationError:
                # Expected behavior - authentication errors should not open circuit
                pass
        
        # Verify circuit is still CLOSED
        assert tws_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
    @pytest.mark.asyncio
    async def test_llm_circuit_breaker_excludes_llm_errors(self):
        """Test that LLM circuit breaker doesn't open on LLMError."""
        # Create a mock function that raises LLMError
        async def failing_llm_operation():
            raise LLMError("Simulated LLM error")
        
        # Test that LLMError doesn't trigger circuit breaker
        for i in range(10):
            try:
                await llm_breaker.call_async(failing_llm_operation)
                assert False, "Expected LLMError to be raised"
            except LLMError:
                # Expected behavior - LLM errors should not open circuit
                pass
        
        # Verify circuit is still CLOSED
        assert llm_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
class TestCircuitBreakerListeners:
    """Test that circuit breaker listeners properly log state changes and metrics."""
    
    @pytest.mark.asyncio
    async def test_redis_breaker_listener_logs_state_changes(self):
        """Test that Redis breaker listener logs state changes."""
        # Create a mock logger
        with patch.object(logger, 'warning') as mock_warning:
            # Create a mock function that raises ConnectionError
            async def failing_redis_operation():
                raise RedisConnectionError("Simulated Redis connection error")
            
            # Trigger 3 failures to open the circuit
            for i in range(3):
                try:
                    await redis_breaker.call_async(failing_redis_operation)
                except RedisConnectionError:
                    pass
            
            # Verify that the listener logged the state change
            mock_warning.assert_called()
            
            # Check that the log message contains the expected information
            call_args = mock_warning.call_args[0]
            assert "redis_circuit_breaker_opened" in call_args[0]
            
    @pytest.mark.asyncio
    async def test_redis_breaker_listener_records_metrics(self):
        """Test that Redis breaker listener records metrics."""
        # Create a mock metrics recorder
        with patch.object(runtime_metrics, 'record_health_check') as mock_record:
            # Create a mock function that raises ConnectionError
            async def failing_redis_operation():
                raise RedisConnectionError("Simulated Redis connection error")
            
            # Trigger 3 failures to open the circuit
            for i in range(3):
                try:
                    await redis_breaker.call_async(failing_redis_operation)
                except RedisConnectionError:
                    pass
            
            # Verify that the listener recorded the health check
            mock_record.assert_called()
            
            # Check that the health check was recorded with the expected parameters
            call_args = mock_record.call_args[0]
            assert call_args[0] == "redis_circuit_breaker"
            assert call_args[1] == "opened"
            
class TestCircuitBreakerDecorators:
    """Test that the convenience decorators work properly."""
    
    @pytest.mark.asyncio
    async def test_redis_protected_decorator(self):
        """Test that redis_protected decorator works properly."""
        # Create a mock function that raises ConnectionError
        @redis_protected
        async def failing_redis_operation():
            raise RedisConnectionError("Simulated Redis connection error")
        
        # Test that the decorator works
        for i in range(3):
            try:
                await failing_redis_operation()
                assert False, "Expected ConnectionError to be raised"
            except RedisConnectionError:
                # Expected behavior - failure should be counted
                pass
        
        # Fourth call should fail-fast with CircuitBreakerError
        try:
            await failing_redis_operation()
            assert False, "Expected CircuitBreakerError to be raised"
        except Exception as e:
            # Verify it's a CircuitBreakerError (aiobreaker specific)
            assert "CircuitBreakerError" in str(type(e)) or "open" in str(e).lower()
            
    @pytest.mark.asyncio
    async def test_tws_protected_decorator(self):
        """Test that tws_protected decorator works properly."""
        # Create a mock function that raises AuthenticationError
        @tws_protected
        async def failing_tws_operation():
            raise AuthenticationError("Simulated TWS authentication error")
        
        # Test that the decorator works
        for i in range(10):
            try:
                await failing_tws_operation()
                assert False, "Expected AuthenticationError to be raised"
            except AuthenticationError:
                # Expected behavior - authentication errors should not open circuit
                pass
        
        # Verify circuit is still CLOSED
        assert tws_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
    @pytest.mark.asyncio
    async def test_llm_protected_decorator(self):
        """Test that llm_protected decorator works properly."""
        # Create a mock function that raises LLMError
        @llm_protected
        async def failing_llm_operation():
            raise LLMError("Simulated LLM error")
        
        # Test that the decorator works
        for i in range(10):
            try:
                await failing_llm_operation()
                assert False, "Expected LLMError to be raised"
            except LLMError:
                # Expected behavior - LLM errors should not open circuit
                pass
        
        # Verify circuit is still CLOSED
        assert llm_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
class TestCircuitBreakerManualCalls:
    """Test that manual call methods work properly."""
    
    @pytest.mark.asyncio
    async def test_call_with_redis_breaker(self):
        """Test that call_with_redis_breaker works properly."""
        # Create a mock function that raises ConnectionError
        async def failing_redis_operation():
            raise RedisConnectionError("Simulated Redis connection error")
        
        # Test that the manual call method works
        for i in range(3):
            try:
                await call_with_redis_breaker(failing_redis_operation)
                assert False, "Expected ConnectionError to be raised"
            except RedisConnectionError:
                # Expected behavior - failure should be counted
                pass
        
        # Fourth call should fail-fast with CircuitBreakerError
        try:
            await call_with_redis_breaker(failing_redis_operation)
            assert False, "Expected CircuitBreakerError to be raised"
        except Exception as e:
            # Verify it's a CircuitBreakerError (aiobreaker specific)
            assert "CircuitBreakerError" in str(type(e)) or "open" in str(e).lower()
            
    @pytest.mark.asyncio
    async def test_call_with_tws_breaker(self):
        """Test that call_with_tws_breaker works properly."""
        # Create a mock function that raises AuthenticationError
        async def failing_tws_operation():
            raise AuthenticationError("Simulated TWS authentication error")
        
        # Test that the manual call method works
        for i in range(10):
            try:
                await call_with_tws_breaker(failing_tws_operation)
                assert False, "Expected AuthenticationError to be raised"
            except AuthenticationError:
                # Expected behavior - authentication errors should not open circuit
                pass
        
        # Verify circuit is still CLOSED
        assert tws_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
    @pytest.mark.asyncio
    async def test_call_with_llm_breaker(self):
        """Test that call_with_llm_breaker works properly."""
        # Create a mock function that raises LLMError
        async def failing_llm_operation():
            raise LLMError("Simulated LLM error")
        
        # Test that the manual call method works
        for i in range(10):
            try:
                await call_with_llm_breaker(failing_llm_operation)
                assert False, "Expected LLMError to be raised"
            except LLMError:
                # Expected behavior - LLM errors should not open circuit
                pass
        
        # Verify circuit is still CLOSED
        assert llm_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
class TestCircuitBreakerStatusManagement:
    """Test circuit breaker status and management functions."""
    
    def test_get_circuit_breaker_status(self):
        """Test that get_circuit_breaker_status returns correct information."""
        status = get_circuit_breaker_status()
        
        # Verify Redis breaker status
        assert status["redis"]["name"] == "redis_operations"
        assert status["redis"]["fail_counter"] == 0
        assert status["redis"]["timeout_duration"] == "0:00:30"
        
        # Verify TWS breaker status
        assert status["tws"]["name"] == "tws_operations"
        assert status["tws"]["fail_counter"] == 0
        assert status["tws"]["timeout_duration"] == "0:01:00"
        
        # Verify LLM breaker status
        assert status["llm"]["name"] == "llm_operations"
        assert status["llm"]["fail_counter"] == 0
        assert status["llm"]["timeout_duration"] == "0:00:45"
        
    def test_reset_all_circuit_breakers(self):
        """Test that reset_all_circuit_breakers resets all breakers."""
        # Create a mock function that raises ConnectionError
        async def failing_redis_operation():
            raise RedisConnectionError("Simulated Redis connection error")
        
        # Open the Redis circuit breaker
        for i in range(3):
            try:
                await redis_breaker.call_async(failing_redis_operation)
            except RedisConnectionError:
                pass
        
        # Verify circuit is OPEN
        assert redis_breaker.current_state.__class__.__name__ == "CircuitOpenState"
        
        # Reset all circuit breakers
        reset_all_circuit_breakers()
        
        # Verify circuit is CLOSED
        assert redis_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        assert redis_breaker.fail_counter == 0
        
        # Verify TWS and LLM breakers are also reset
        assert tws_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        assert llm_breaker.current_state.__class__.__name__ == "CircuitClosedState"
        
        # Verify fail_counter is reset
        assert tws_breaker.fail_counter == 0
        assert llm_breaker.fail_counter == 0
