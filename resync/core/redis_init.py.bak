Redis Initializer with advanced thread-safe initialization and retry logic.

This module provides a robust Redis connection initialization mechanism 
with comprehensive error handling, distributed locking, and health checks.

import asyncio
import os
import random
import socket
import sys
import logging
from datetime import datetime
from typing import Optional

import redis.asyncio as redis
from redis.exceptions import (
    ConnectionError,
    TimeoutError,
    AuthenticationError,
    BusyLoadingError,
    ResponseError
)

from resync.core.metrics import runtime_metrics

logger = logging.getLogger(__name__)

class RedisInitializer:
    """
    Thread-safe Redis initialization with advanced features:
    - Exponential backoff with jitter
    - Distributed locking
    - Connection validation
    - Health check loop
    - Comprehensive error handling
    """
    
    def __init__(self):
        """
        Initialize the Redis initializer with thread-safe mechanisms.
        """
        self._lock = asyncio.Lock()
        self._initialized = False
        self._client: Optional[redis.Redis] = None
        self._health_check_task: Optional[asyncio.Task] = None
    
    async def initialize(
        self,
        redis_url: Optional[str] = None,
        max_retries: int = 3,
        base_backoff: float = 0.1,
        max_backoff: float = 10.0,
        health_check_interval: int = 5
    ) -> redis.Redis:
        """
        Initialize Redis with comprehensive error handling and retry logic.
        
        Args:
            redis_url: Redis connection URL
            max_retries: Maximum number of connection attempts
            base_backoff: Base backoff time between retries
            max_backoff: Maximum backoff time
            health_check_interval: Interval for background health checks
        
        Returns:
            Initialized Redis client
        
        Raises:
            RuntimeError: If Redis initialization fails after all retries
        """
        
        # Use environment variable or default URL if not provided
        if redis_url is None:
            redis_url = os.getenv("REDIS_URL", "redis://localhost:6379")
        
        async with self._lock:
            # Check if already initialized and connection is valid
            if self._initialized and self._client:
                try:
                    await asyncio.wait_for(self._client.ping(), timeout=1.0)
                    return self._client
                except (Exception, asyncio.TimeoutError):
                    logger.warning("Existing Redis connection lost, reinitializing")
                    self._initialized = False
            
            # Distributed lock key to prevent multiple initializations
            lock_key = "resync:init:lock"
            lock_timeout = 30
            
            # Retry loop with exponential backoff
            for attempt in range(max_retries):
                try:
                    # Create Redis client with optimized pool
                    redis_client = await self._create_client_with_pool(redis_url)
                    
                    # Attempt to acquire distributed lock
                    acquired = await redis_client.set(
                        lock_key,
                        f"instance-{os.getpid()}",
                        nx=True,
                        ex=lock_timeout
                    )
                    
                    # If lock not acquired, wait and retry
                    if not acquired:
                        logger.info(
                            f"Another instance is initializing Redis, "
                            f"waiting... (attempt {attempt + 1}/{max_retries})"
                        )
                        await asyncio.sleep(2)
                        continue
                    
                    try:
                        # Validate connection with ping
                        await asyncio.wait_for(redis_client.ping(), timeout=2.0)
                        
                        # Perform read/write test
                        test_key = f"resync:health:test:{os.getpid()}"
                        await redis_client.set(test_key, "ok", ex=60)
                        test_value = await redis_client.get(test_key)
                        
                        if test_value != b"ok":
                            raise ValueError("Redis read/write test failed")
                        
                        await redis_client.delete(test_key)
                        
                        # Store client and mark as initialized
                        self._client = redis_client
                        self._initialized = True
                        
                        # Log successful initialization
                        logger.info(
                            "Redis initialized successfully",
                            extra={
                                "attempt": attempt + 1,
                                "pool_size": redis_client.connection_pool.max_connections
                            }
                        )
                        
                        # Start background health check
                        self._health_check_task = asyncio.create_task(
                            self._health_check_loop(health_check_interval)
                        )
                        
                        return redis_client
                        
                    finally:
                        # Always release the lock
                        await redis_client.delete(lock_key)
                    
                except (ConnectionError, TimeoutError, BusyLoadingError) as e:
                    # Handle connection-related errors with retry
                    if attempt >= max_retries - 1:
                        logger.critical(
                            f"Redis initialization failed after {max_retries} attempts",
                            exc_info=True
                        )
                        sys.exit(1)
                    
                    # Exponential backoff with jitter
                    backoff = min(max_backoff, base_backoff * (2 ** attempt))
                    jitter = random.uniform(0, 0.1 * backoff)
                    total_wait = backoff + jitter
                    
                    logger.warning(
                        f"Redis connection failed (attempt {attempt + 1}/{max_retries}): {e}. "
                        f"Retrying in {total_wait:.2f}s"
                    )
                    await asyncio.sleep(total_wait)
                    
                except AuthenticationError as e:
                    logger.critical(f"Redis authentication failed: {e}")
                    sys.exit(1)
                    
                except Exception as e:
                    logger.critical(
                        f"Unexpected error during Redis initialization",
                        exc_info=True
                    )
                    sys.exit(1)
        
        raise RuntimeError("Redis initialization failed")
    
    async def _create_client_with_pool(self, redis_url: str) -> redis.Redis:
        """
        Create Redis client with optimized connection pool.
        
        Args:
            redis_url: Redis connection URL
        
        Returns:
            Configured Redis client
        """
        return redis.Redis.from_url(
            redis_url,
            encoding="utf-8",
            decode_responses=True,
            max_connections=50,
            socket_connect_timeout=5,
            socket_keepalive=True,
            socket_keepalive_options={
                socket.TCP_KEEPIDLE: 60,
                socket.TCP_KEEPINTVL: 10,
                socket.TCP_KEEPCNT: 3
            },
            health_check_interval=30,
            retry_on_timeout=True,
            retry_on_error=[ConnectionError, TimeoutError]
        )
    
    async def _health_check_loop(self, interval: int):
        """
        Background health check to monitor Redis connection.
        
        Args:
            interval: Interval between health checks in seconds
        """
        while self._initialized:
            try:
                await asyncio.sleep(interval)
                
                if self._client:
                    await asyncio.wait_for(self._client.ping(), timeout=2.0)
                    
            except (Exception, asyncio.TimeoutError) as e:
                logger.error(
                    "Redis health check failed - connection may be lost",
                    exc_info=True
                )
                self._initialized = False
            except Exception as e:
                logger.error("Error in Redis health check", exc_info=True)
    
    async def close(self):
        """
        Close Redis connection and cleanup resources.
        """
        if self._health_check_task:
            self._health_check_task.cancel()
        
        if self._client:
            await self._client.close()
            await self._client.connection_pool.disconnect()